---
id: glossary
title: Glossary of React Terms
layout: docs
category: Reference
permalink: docs/glossary.html

---

## برنامه‌ تک-صفحه‌ای {#single-page-application}

یک برنامه‌-تک صفحه‌ای برنامه‌ی است که یک صفحه HTML با تمامی ملزومات آن (مثل جاوا‌اسکریپت و css) که برای اجرا شدن برنامه‌ نیاز هست را بارگیری می‌کند. هر تعاملی با صفحه یا سایر صفحات، دیگر نیازی به ارسال در‌خواست به سمت سرور نیاز ندارد که به معنی عدم بارگیری مجدد صفحه است.

اگرچه می‌توان یک برنامه تک-صفحه‌ای با ری‌اکت بسازید، اما استفاده از ری‌اکت الزامی نیست. همچنین می‌توان از آن برای بهبود بخش‌های کوچک وبسایت‌های موجود استفاده کرد. کد نوشته شده با ری‌اکت می‌تواند همراه با markup رندر شده سمت سرور، توسط زبانی مثل PHP یا کتاب‌خانه‌های سمت کاربر هم‌زیستی کند. در واقع، ری‌اکت به همین صورت در فیس‌بوک استفاده می‌شود.

## ES6، ES2015، ES2016 و غیره {#es6-es2015-es2016-etc}

تمام این کلمات اختصاری به جدیدترین ورژن‌های مشخصات استاندارد زبان ECMAScript اشاره می‌کند که زبان جاواسکریپت پیاده‌سازی‌ای از آن است. ورژن ES6 (که به ES2015 معروف است) مواردی به نسخه‌های قبلی افزوده‌است، مانند: توابع arrow، کلاس‌ها، template literals ،`let` و `const`. شما می‌توانید در مورد ورژن ها [اینجا](https://en.wikipedia.org/wiki/ECMAScript#Versions) اطلاعات بیشتری کسب کنید.

## کامپایلر‌ها {#compilers}

یک کامپایلر جاوااسکریپت کد جاوااسکریپت را دریافت کرده، آن را تغییر شکل می‌دهد و کد جاوااسکریپت را با قالب متفاوتی باز می‌گرداند. یک مورد استفاده مرسوم، آنست که کد ES6 شما رو دریافت می‌کند و دست‌خط آن‌را به چیزی که مرورگر‌های قدیمی می‌فهمند تبدیل می‌کند. [Babel](https://babeljs.io/) کامپایلری هست که عموما در ری‌اکت استفاده می‌شود.
[Babel](https://babeljs.io/) کامپایلری هست که عموما در ری‌اکت استفاده می‌شود.

## Bundlers {#bundlers}

Bundlerها کد جاوااسکریپت و CSS را از ماژول‌های جداگانه را می‌گیرند (معمولا صدها ماژول) و آنها را در یک فایل جدید که برای مرورگرها بهتر بهینه سازی شده است ترکیب می‌کنند. برخی از Bundlerها که در ری‌اکت استفاده شده‌اند مانند [Webpack](https://webpack.js.org/) و [Browserify](http://browserify.org/) هستند.

## Package Managers {#package-managers}

package managerها ابزارهایی هستند که به شما امکان می‌دهند تا وابستگی‌های پروژه را مدیریت کنید. [npm](https://www.npmjs.com/) و [Yarn](https://yarnpkg.com/) دو package manager مرسوم در برنامه‌های ری‌اکت استفاده شده‌اند. هر دوی آنها مشتری npm registery هستند.

## CDN {#cdn}

CDN مخفف Content Delivery Network (شبکه تحویل‌ محتوا) است. CDNها محتوای cach شده یا استای یک شبکه از سرور‌ها در سراسر دنیا را تحویل می‌دهند.

## JSX {#jsx}

JSX افزونه‌ای بر syntax جاوااسکریپت است. به یک زبان template شبیه است ولی دارای تمام قدرت جاوااسکریپت می‌باشد. JSX توسط فراخوانی `React.createElement()` کامپایل می‌شود که یک شی جاوااسکریپتی ساده به نام "React elements" را باز می‌گرداند. مقدمه‌ای بر مفاهیم پایه‌ای JSX [در این سند آورده شده‌است](/docs/introducing-jsx.html) و می‌توانید آموزش عمیق‌تری در [اینجا](/docs/jsx-in-depth.html) پیدا کنید.

در DOM ری‌اکت عرف نامگذاری property ها به‌جای اسامی attribute های HTML، به صورت camleCase است. در JSX برای مثال `tabindex` به `tabIndex` تبدیل می‌شود.
همچنین خصیصه `class` به شکل `className` نوشته می‌شود زیرا کلمه `class` در زبان جاوااسکریپت رزرو شده است.

```js
const name = 'Clementine';
ReactDOM.render(
  <h1 className="hello">My name is {name}!</h1>,
  document.getElementById('root')
);
```  

## [المنت‌ها](/docs/rendering-elements.html) {#elements}

المنت‌های (elements) ری‌اکت بلاک‌هایی هستند که برنامه‌های ری‌اکت را می‌سازند. فردی ممکن است المنت‌ها را با مفهموم متداول "کامپوننت" اشتباه بگیرد. یک المنت چیزی را که می‌خواهید در صفحه نمایش دهید را نشان می‌دهد. المن‌های ری‌اکت تغییر ناپذیر (immutable) هستند.

```js
const element = <h1>Hello, world</h1>;
```
معمولا المنت‌ها مستقیم استفاده نمی‌شوند، بلکه توسط کامپوننت‌ها باز گردانده می‌شوند.

## [کامپوننت‌ها](/docs/components-and-props.html) {#components}

کامپوننت‌های ری‌اکت تکه‌های قابل استفاده کوچک کد هستند که یک element ری ‌اکت برمی‌گردانند تا در صفحه رندر شود. ساده‌ترین ورژن یک کامپوننت ری‌اکت یک تابع جاوااسکریپت ساده است که یک element ری‌اکت باز می‌گرداند.

```js
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
```

همچنین کامپوننت‌ها می‌توانند کلاس‌های ES6 باشند:

```js
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```

کامپوننت‌ها می‌توانند به تکه‌های عملکرد مجزا شکسته شوند و در کامپوننت‌های دیگر استفاده شوند. کامپوننت‌ها می‌توانند کامپوننت‌های دیگر، متن و عدد برگردانند، یک قانون خوب آنست که اگر کامپوننت شما چندین بار در UI مورد استفاده قرار گرفت (دکمه، پنل، آواتار)، یا به نوبه خودش به اندازه کافی پیچیده شده بود (برنامه‌،FeedStory، کامنت‌ها)، کاندید خوبی است برای اینکه به یک کامپوننتی تبدیل شود که قابلیت استفاده مجدد داشته باشد.
همچنین نام کامپوننت‌ها باید همیشه با حرف بزرگ شروع شود.(`<Wrapper/>` **نه** `<wrapper/>`). برای کسب اطلاعات بیشتر در مورد رندر شدن کامپوننت‌ها [این سند را مشاهده کنید](/docs/components-and-props.html#rendering-a-component). 

### [`props`](/docs/components-and-props.html) {#props}

`props` ورودی‌های کامپوننت ری‌اکت هستند. آنها داده‌هایی هستند که از کامپوننت پدر به کامپوننت فرزند انتقال پیدا می‌کنند.
به خاطر داشته باشید که`props`ها را فقط می‌توان خواند. نباید آنها را به هیچ طریقی تغییر داد:

```js
// Wrong!
props.number = 42;
```
اگر نیاز دارید مقداری را در پاسخ به ورودی کاربر یا شبکه تغییر دهید به جای آن از `state` استفاده کنید.

### `props.children` {#propschildren}

`props.children` در هر کامپوننتی قابل دسترس است. شامل محتوای بین باز شدن و بسته شدن تگ یک کامپوننت است. برای مثال:

```js
<Welcome>Hello world!</Welcome>
```

متن `Hello world!` در `props.children` در کامپوننت `Welcome` در دسترس است:

```js
function Welcome(props) {
  return <p>{props.children}</p>;
}
```

برای کامپوننت‌هایی که از کلاس استفاده می‌کنند از `this.props.children` استفاده کنید:

```js
class Welcome extends React.Component {
  render() {
    return <p>{this.props.children}</p>;
  }
}
```

### [`state`](/docs/state-and-lifecycle.html#adding-local-state-to-a-class) {#state}

کامپوننت هنگامی به `state` نیاز دارد که داده‌ای که با‌ آن در ارتباط است در طول زمان تغییر کند.برای مثال، کامپوننت `Checkbox` شاید به `isChecked` در state خود نیاز داشته باشد، و کامپوننت `NewsFeed` شاید بخواهد تا `fetchedPosts` را در state خود دنبال کند.

بزرگترین فرق بین `state` و `props` آن است که `هاprop` از طریق کامپوننت پدر انتقال پیدا می‌کنند، ولی `state` توسط خود کامپوننت مدیریت می‌شود. کامپوننت نمی‌تواند `هایprop` خودش را تغییر دهد، ولی می‌تواند `state` خودش را تغییر دهد.

برای هر تکه خاص از تغییر داده، باید فقط یک کامپوننت باشد که آن را در stateاش ازآن خود کند. سعی نکنید که state دو کامپوننت مختلف را باهم یکسان کنید. به جای این کار، آن را به نزدیکترین کامپوننت جد که بین آنها به اشتراک گذاشته شده [انتقال دهید](/docs/lifting-state-up.html) و سپس به هر دوی آنها از بالا به پایین انتقال دهید.

## [Lifecycle Methods](/docs/state-and-lifecycle.html#adding-lifecycle-methods-to-a-class) {#lifecycle-methods}

متد‌های چرخه حیات توابع شخصی‌سازی شده ای هستند که در فاز‌های مختلف یک کامپوننت فراخوانی می‌شوند. برای زمانی که کامپوننت ساخته می‌شود و درون DOM اضافه می‌شود([mounting](/docs/react-component.html#mounting))، زمانی که کامپوننت به‌روز رسانی می‌شود، و زمانی که کامپوننت unmounted یا پاک می‌شود متد‌هایی وجود دارند.

 ## [Controlled](/docs/forms.html#controlled-components) vs. [Uncontrolled Components](/docs/uncontrolled-components.html)

ری‌اکت دو نوع روش برای کار با input فرم ها دارد:

input elementای که مقدار آن توسط ری‌اکت کنترل می‌شود را *controlled component* (کامپوننت های کنترل شده) می‌خوانند.  هنگامی که کاربر داده‌ای درون یک کامپوننت کنترل شده وارد می‌کند روی‌داد کنترل تغییر فعال می‌شود و کد شما تصمیم می‌گیرد که input شما معتبر است یا خیر (با استفاده از به‌روز رسانی مقدار). اگر شما مجددا رندر نکنید آن input دست نخورده باقی می‌ماند.

یک *uncontrolled component* (کامپوننت‌های کنترل نشده) مانند elementهای خارج از ری‌اکت کار می‌کند. اگر کاربر داده‌ای درون فیلدی از فرم وارد کند (input, dropdown, وغیره) اطاعات بدون اینکه ری‌اکت در موردش کاری کند تاثیر می‌پذیرند. همچنین، این به آن معناست که شما نمی‌توانید فیلد را مجبور کنید تا مقدار خاصی داشته باشد.

در اکثر موارد باید از کامپوننت‌های کنترل شده استفاده کنید.

## [Keys](/docs/lists-and-keys.html) {#keys}

“key” متن خصیصه خاصی هست که هنگام ایجاد آرایه‌ای از elementها باید آن را اضافه کنیم. Keyها به ری‌اکت کمک می‌کنند که چه آیتمی تغییر کرده، اضافه شده، یا پاک شده است. Keyها باید به elementهای درون آرایه داده شوند تا هویت ثابتی داشته باشند.

Keyها فقط باید بین هم نژادهایشان درون یک آرایه، منحصر به فرد باشند. نیازی نیست که در تمام برنامه یا حتی درون یک کامپوننت  منحصر به فرد باشند.

چیزی مثل `Math.random()` را برای keyها قرار ندهید. بسیار مهم است که keyها "هویت ثابت" در بین هر رندر داشته باشند تا ری‌اکت بتواند هنگامی که آیتمی  اضافه، کم یا مجددا به‌روز رسانی شد تشخیص دهد. در حالت ایده آل، keyها باید با هویت باثباتی که از داده‌های شما می‌آیند مطابق باشند، مانند `post.id`.

## [Refs](/docs/refs-and-the-dom.html) {#refs}

ری‌اکت از خصیصه‌ای پشتیبانی می‌کند که شما می‌توانید به هر کامپوننتی بچسبانید. خصیصه `ref` می‌تواند آبجکتی ساخته شده توسط [`تابع ()React.createRef`](/docs/react-api.html#reactcreateref) یا تابع callback، یا یک متن باشد (در Api قدیم). هنگامی که خصیصه `ref` یک callback باشد، تابع element نهفته DOM و یا instance کلاس را به عنوان آرگومان دریافت می‌کند (بسته به نوع element). این به شما اجازه می‌دهد تا به element DOM یا instance کلاس دسترسی داشته باشید.
از ref زیاد استفاده نکنید. اگر دیدید که مکرر از ref در برنامه‌تان استفاده می‌کنید تا همه چیز اتفاق بیافتد در نظر داشته باشید که با [جریان داده از بالا به پایین](/docs/lifting-state-up.html). بیشتر آشنا شوید.

## [Events](/docs/handling-events.html) {#events}

مدیریت رخ‌دادها با المنت‌های ری‌اکت تفاوت‌های در قواعد دارد:

* در ری‌اکت، event handler ها طبق قانون camleCase به‌جای lowercase نامگذاری می‌شوند.
* با بهره‌گیری از JSX، شما یک تابع را به‌جای یک رشته به event handler پاس می‌دهید.

## [تلفیق](/docs/reconciliation.html) {#reconciliation}

هنگامی که props یا state تغییر می‌کند، ری‌اکت با مقایسه المنت‌های بازگشت داده شده و آنهایی که قبلا رندر شده بودند تصمیم می‌گید که DOM  اصلی به‌روز رسانی شود یا خیر. هنگامی که با هم برابر نباشند، ری‌اکت DOM را به‌روز رسانی می‌کند. این پروسه تلفیق (reconciliation) خوانده می‌شود.
