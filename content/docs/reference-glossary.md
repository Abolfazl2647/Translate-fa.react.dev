---
id: glossary
title: Glossary of React Terms
layout: docs
category: Reference
permalink: docs/glossary.html

---

## نرم‌افزار تک-صفحه‌ای {#single-page-application}

یک نرم‌افزار-تک صفحه‌ای نرم‌افزاری است که یک صفحه HTML با تمامی دارایی‌های ضروری‌اش (مثل جاوا‌اسکریپت و سی اس اس) که برای اجرا شدن نرم‌افزار نیاز هست را بارگیری می‌کند. تمام فعل و انفعالاتی که در صفحه رخ می‌دهد و آنهایی که متعاقبا رخ می‌دهند دیگر به گردشی به دور سرور نیاز ندارند که به این معنیست که صفحه مجددا بارگیری نمی‌شود.

شاید یک برنامه تک صفحه‌ای با ری‌اکت بسازید، اما ری‌اکت یک نیاز ضروری نیست. ری‌کت میتواند برای بهبود قسمت کوچکی از وبسایت حاضر با تعامل اضافی استفاده شود. کد ری‌اکت می‌تواند به شکل مسالمت آمیزی با مارکاپ رندر شده سمت سرور توسط زبانی مثل PHP یا کتابخانه‌های سمت کاربر هم زیستی کند. در واقع، این دلیلیست که ری‌اکت در فیس‌بوک استفاده می‌شود.

## ES6, ES2015, ES2016, و غیره {#es6-es2015-es2016-etc}

تمام این کلمات اختصاری به جدیدترین ورژن استاندارد‌های زبان ECMAScript اشاره می‌کند که زبان جاواسکریپت از آن پیاده‌سازی  شده است. ورژن ES6 (که به ES2015 معروف است ) چند ضمیمه به ورژن قبلی اضافه کرده است مانند: توابع پیکانی, کلاس‌ها, template literals, `let` و `const`. شما می‌توانید در مورد ورژن ها [اینجا](https://en.wikipedia.org/wiki/ECMAScript#Versions) اطلاعات بیشتری کسب کنید.

## کامپایلر‌ها {#compilers}

کامپایلر جاوااسکریپت کد جاوااسکریپت شما رو می‌گیرد، و آن‌را به حالت دیگری تبدیل می‌کند. یکی از مواردی که به طور عمومی مورد استفاده قرار می‌گیرد آنست که کد ES6 شما رو دریافت می‌کند و دست خط آن‌را به چیزی که مرورگر‌های قدیمی می‌فهمند تبدیل می‌کند.
[Babel](https://babeljs.io/) کامپایلری هست که عموما در ری‌اکت استفاده می‌شود.

## Bundlers {#bundlers}

Bundlerها کد جاوااسکریپت و سی‌اس‌اس از ماژول‌های جداگانه را می‌گیرند (معملا صدها ماژول) و آنها را در یک فایل جدید که برای مرورگرها بهتر بهینه سازی شده است ترکیب می‌کنند. برخی از Bundlerها در ری‌اکت اضافه شده است مانند [Webpack](https://webpack.js.org/) و [Browserify](http://browserify.org/).

## Package Managers {#package-managers}

Package managerها ابزارهایی هستند که به شما امکان می‌دهند تا وابستگی‌های پروژه را مدیریت کنید. [npm](https://www.npmjs.com/) و [Yarn](https://yarnpkg.com/) دو Package managerای هستند که عموما در نرم‌افزارهای ری‌اکت استفاده شده‌اند. هر دوی آنها به نوعی ارباب رجوع رجیستری بسته NPM هستند.

## CDN {#cdn}

CDN مخخف Content Delivery Network (شبکه تحویل‌دهی محتوا) است. CDNها محتوای کش شده یا ایستایی یک شبکه از سرور‌ها در سراسر دنیا را تحویل می‌دهند.

## JSX {#jsx}

JSX یک افزونه‌ی دست‌خط برای جاوااسکریپت است. به زبان template شبیه است ولی دارای تمام قدرت جاوااسکریپت می‌باشد. JSX توسط فراخوانی `React.createElement()` کامپایل می‌شود که یک شی جاوااسکریپتی ساده به نام "React elements" را باز می‌گرداند. برای دست‌یابی به معرفی JSX می‌توانید [این سند را ببینید](/docs/introducing-jsx.html) و آموزش عمیق‌تری در [اینجا](/docs/jsx-in-depth.html) پیدا کنید.

ری‌اکت Dom از نگارش شتری به‌جای نحوه نام گذاری در خصیصه‌های HTML برای نام گذاری خود استفاده می‌کند. برای مثال `tabindex` در JSX می‌شود `tabIndex`.
همچنین خصیصه `class` به شکل `className` نوشته می‌شود زیرا کلمه `class` در زبان جاوااسکریپت رزرو شده است.

```js
const name = 'Clementine';
ReactDOM.render(
  <h1 className="hello">My name is {name}!</h1>,
  document.getElementById('root')
);
```  

## [Elements](/docs/rendering-elements.html) {#elements}

elementهای ری‌اکت بلاک‌هایی هستند که نرم‌افزارهای ری‌اکت را می‌سازند. فردی ممکن است elementها را با مفهموم گسترش یافته "کامپوننت" اشتباه بگیرد. یک المنت چیزی را که می‌خواهید در صفحه نمایش دهید را نشان می‌دهد. المان‌های ری‌اکت immutable هستند.

```js
const element = <h1>Hello, world</h1>;
```
معمولا، elementها مستقیما استفاده نمی‌شوند، ولی از کامپوننت ها برمی‌گردند.

## [Components](/docs/components-and-props.html) {#components}

کامپوننت‌های ری‌اکت تکه‌های قابل استفاده کوچک کد هستند که یک element ری ‌اکت برمی‌گردانند تا در صفحه رندر شود. ساده‌ترین ورژن یک کامپوننت ری‌اکت یک تابع جاوااسکریپت ساده است که یک element ری‌اکت باز می‌گرداند.

```js
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
```

همچنین کامپوننت‌ها می‌توانند کلاس‌های ES6 باشند:

```js
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```

کامپوننت‌ها می‌توانند به تکه‌های مجزای عملکردی شکسته شوند و در کامپوننت‌های دیگر استفاده شوند. کامپوننت‌ها می‌توانند کامپوننت‌های دیگر، متن و عدد برگردانند، یک قانون خوب آنست که اگر کامپوننت شما چندین بار در UI مورد استفاده قرار گرفت (دکمه، پنل، آواتار)، یا به نوبه خودش به اندازه کافی پیچیده شده بود (نرم‌افزار،FeedStory، کامنت‌ها)، کاندید خوبی است برای اینکه به یک کامپوننت قابل استفاده مجدد تبدیل شود.
همچنین نام کامپوننت‌ها باید همیشه با حرف بزرگ شروع شود.(`<Wrapper/>` **نه** `<wrapper/>`). برای کسب اطلاعات بیشتر در مورد رندر شدن کامپوننت‌ها [این سند را مشاهده کنید](/docs/components-and-props.html#rendering-a-component). 

### [`props`](/docs/components-and-props.html) {#props}

`props` ورودی‌های کامپوننت ری‌اکت هستند. آنها داده‌هایی هستند که از کامپوننت پدر به کامپوننت فرزند انتقال پیدا می‌کنند.
به خاطر داشته باشید که`props`ها را فقط می‌توان خواند. نباید آنها را به هیچ طریقی تغییر داد:

```js
// Wrong!
props.number = 42;
```
اگر نیاز دارید مقداری را در پاسخ به ورودی کاربر یا شبکه تغییر دهید به جای آن از `state` استفاده کنید.

### `props.children` {#propschildren}

`props.children` در هر کامپوننتی قابل دسترس است. شامل محتوای بین باز شدن و بسته شدن تگ یک کامپوننت است. برای مثال:

```js
<Welcome>Hello world!</Welcome>
```

متن `Hello world!` در `props.children` در کامپوننت `Welcome` در دسترس است:

```js
function Welcome(props) {
  return <p>{props.children}</p>;
}
```

برای کامپوننت‌هایی که از کلاس استفاده می‌کنند از `this.props.children` استفاده کنید:

```js
class Welcome extends React.Component {
  render() {
    return <p>{this.props.children}</p>;
  }
}
```

### [`state`](/docs/state-and-lifecycle.html#adding-local-state-to-a-class) {#state}

هنگامی که داده‌ای که با کامپوننت در ارتباط است در و در طول زمان دچار تغییر می‌شود، کامپوننت به `state` نیاز دارد. برای مثال، کامپوننت `Checkbox` شاید به `isChecked` در  state خود نیاز داشته باشد، و کامپوننت `NewsFeed` شاید بخواهد تا `fetchedPosts` را در state خود دنبال کند.

بزرگترین فرق بین `state` و `props` آن است که `هاprop` از طریق کامپوننت پدر انتقال پیدا می‌کنند، ولی `state` توسط خود کامپوننت مدیریت می‌شود. کامپوننت نمی‌تواند `هایprop` خودش را تغییر دهد، ولی می‌تواند `state` خودش را تغییر دهد.

برای هر تکه خاص از تغییر داده، باید فقط یک کامپوننت باشد که آن را در stateاش ازآن خود کند. سعی نکنید که state دو کامپوننت مختلف را باهم یکسان کنید. به جای این کار، آن را به نزدیکترین کامپوننت جد که بین آنها به اشتراک گذاشته شده [انتقال دهید](/docs/lifting-state-up.html) و سپس به هر دوی آنها از بالا به پایین انتقال دهید.

## [Lifecycle Methods](/docs/state-and-lifecycle.html#adding-lifecycle-methods-to-a-class) {#lifecycle-methods}

متد‌های چرخه حیات توابع شخصی‌سازی شده ای هستند که در فاز‌های مختلف یک کامپوننت فراخوانی می‌شوند. برای زمانی که کامپوننت ساخته می‌شود و درون DOM اضافه می‌شود([mounting](/docs/react-component.html#mounting))، زمانی که کامپوننت به‌روز رسانی می‌شود، و زمانی که کامپوننت unmounted یا پاک می‌شود متد‌هایی وجود دارند.

 ## [Controlled](/docs/forms.html#controlled-components) vs. [Uncontrolled Components](/docs/uncontrolled-components.html)

ری‌اکت دو نوع روش برای کار با input فرم ها دارد:

input elementای که مقدار آن توسط ری‌اکت کنترل می‌شود را *controlled component* (کامپوننت های کنترل شده) می‌خوانند.  هنگامی که کاربر داده‌ای درون یک کامپوننت کنترل شده وارد می‌کند روی‌داد کنترل تغییر فعال می‌شود و کد شما تصمیم می‌گیرد که input شما معتبر است (با استفاده از به‌روز رسانی مقدار). اگر شما مجددا رندر نکنید آن input دست نخورده باقی می‌ماند.

یک *uncontrolled component* (کامپوننت‌های کنترل نشده) مانند elementهای خارج از ری‌اکت کار می‌کند. اگر کاربر داده‌ای درون فیلدی از فرم وارد کند (input, dropdown, وغیره) اطاعات بدون اینکه ری‌اکت در موردش کاری کند تاثیر می‌پذیرند. همچنین، این به آن معناست که شما نمی‌توانید فیلد را مجبور کنید تا مقدار خاصی داشته باشد.

در اکثر موارد باید از کامپوننت‌های کنترل شده استفاده کنید.

## [Keys](/docs/lists-and-keys.html) {#keys}

"key" متن خصیصه خاصی هست که هنگامی که میخواهید آرایه ای از elementها را ایجاد کنید نیاز دارید که وارد کنید. Keyها به ری‌اکت کمک می‌کنند که چه آیتمی تغییر کرده، اضافه شده، یا پاک شده است. Keyها باید به elementهای درون آرایه داده شوند تا هویت ثابتی داشته باشند.

Keyها فقط باید بین هم نژادهایشان درون یک آرایه، منحصر به فرد باشند.نیازی نیست که در تمام برنامه یا حتی درون یک کامپوننت  منحصر به فرد باشند.

چیزی مثل `Math.random()` را برای keyها قرار ندهید. بسیار مهم است که keyها "هویت ثابت" در بین هر رندر داشته باشند تا ری‌اکت بتواند هنگامی که آیتمی  اضافه، کم یا مجددا به‌روز رسانی شد تشخیص دهد. در حالت ایده آل، keyها باید با هویت باثباتی که از داده‌های شما می‌آیند مطابق باشند، مانند `post.id`.

## [Refs](/docs/refs-and-the-dom.html) {#refs}

ری‌اکت از خصیصه‌ای پشتیبانی می‌کند که شما می‌توانید به هر کامپوننتی بچسبانید. خصیصه `ref` می‌تواند آبجکتی ساخته شده توسط [`تابع ()React.createRef`](/docs/react-api.html#reactcreateref) یا تابع callback، یا یک متن باشد (در Api قدیم). هنگامی که خصیصه `ref` یک callback باشد، تابع element نهفته DOM و یا instance کلاس را به عنوان آرگومان دریافت می‌کند (بسته به نوع element). این به شما اجازه می‌دهد تا به element DOM یا instance کلاس دسترسی داشته باشید.
از ref زیاد استفاده نکنید. اگر دیدید که مکرر از ref در نرم‌افزارتان استفاده می‌کنید تا همه چیز اتفاق بیافتد در نظر داشته باشید که با [جریان داده از بالا به پایین](/docs/lifting-state-up.html). بیشتر آشنا شوید.

## [Events](/docs/handling-events.html) {#events}

کنترل روی‌دادها با elementهای ری‌اکت قواعد صرف ونحوی متفاوتی دارد :

* کنترلر‌های روی داد ری‌اکت به شکل شتری نوشته می‌شوند به جای آنکه با حروف کوچک نوشته شوند.
* با JSX شما تابع را به عنوان کنترل روی‌داد انتقال می‌دهید به جای انتقال یک متن.

## [Reconciliation](/docs/reconciliation.html) {#reconciliation}

هنگامی که propها یا state تغییر می‌کند، ری‌اکت با مقایسه elementهای بازگشت داده شده و آنهایی که قبلا رندر شده بودند تصمیم می‌گید که DOM  اصلی به‌روز رسانی شود یا خیر. هنگامی که با هم برابر نباشند، ری‌اکت DOM را به‌روز رسانی می‌کند. این پردازش "reconciliation" خوانده می‌شود.
