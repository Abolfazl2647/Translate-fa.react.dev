---
id: thinking-in-react
title: فکر کردن در چارچوب ری‌اکت
permalink: docs/thinking-in-react.html
redirect_from:
  - 'blog/2013/11/05/thinking-in-react.html'
  - 'docs/thinking-in-react-zh-CN.html'
prev: composition-vs-inheritance.html
---

به عقیده ما، ری‌اکت بهترین راه برای ساخت وب اپلیکیشن هایی سریع و بزرگ، با استفاده از جاوااسکریپت است و برای ما در فیسبوک و اینستاگرام خیلی خوب جواب داده است.

ری‌اکت بخش های خیلی خوب زیادی دارد، اما یکی از بهترین آنها، چگونگی نگرش به اپ هایی است که مشغول به ساخت آنها هستید.
در این سند (Document)، به فرایند تفکر در ساخت یک جدول محصولات با قابلیت جستجو خواهیم پرداخت، و برای ساخت این جدول از ری‌اکت استفاده میکنیم.


## شروع با یک مدل  {#start-with-a-mock}

تصور کنید که ما از قبل یک JSON API و یک مدل، که توسط طراح آماده شده، داریم. مدل آماده شده، چیزی شبیه به این است:

![Mockup](../images/blog/thinking-in-react-mock.png)

و JSON API هم این اطلاعات را در خود جا داده است:

```
[
  {category: "Sporting Goods", price: "$49.99", stocked: true, name: "Football"},
  {category: "Sporting Goods", price: "$9.99", stocked: true, name: "Baseball"},
  {category: "Sporting Goods", price: "$29.99", stocked: false, name: "Basketball"},
  {category: "Electronics", price: "$99.99", stocked: true, name: "iPod Touch"},
  {category: "Electronics", price: "$399.99", stocked: false, name: "iPhone 5"},
  {category: "Electronics", price: "$199.99", stocked: true, name: "Nexus 7"}
];
```

## قدم اول: رابط کاربری را به یک سلسله از کامپوننت ها تقسیم کنید{#step-1-break-the-ui-into-a-component-hierarchy}

اولین کاری که باید کنید، این است که دور هر کدام از کامپوننت های موجود خط بکشید و تمامی کامپوننت ها را به همراه زیرمجموعه های آن مشخص کنید و برای هر کدام یک نام در نظر بگیرید. (هر کامپوننت ممکن است یک یا چند کامپوننت زیر مجموعه داشته باشد)

اگر به همراه یک طراح (دیزاینر) کار میکنید، ممکن است او قبلا همین کار را انجام داده باشد. نامگذاری آنها برای لایه های مختلف در فایل فتوشاپی که تهیه کرده اند، میتواند نام کامپوننت ها در کد شما هم باشد!

اما چطور بفهمیم که یک بخش باید تبدیل به یک کامپوننت جداگانه شود؟ در این موارد بهتر است از همان تکنیک هایی استفاده کنیم که زمان تصمیم گیری برای تعریف یک تابع Function یا یک شیء Object جدید به کمک مان می آمدند.
یکی از این تکنیک ها ["اصل مسئولیت واحد" یا "اصل تک وظیفگی" ](https://en.wikipedia.org/wiki/Single_responsibility_principle), است.
این اصل بیان میکند که هر کامپوننت، باید در حالت ایده آل فقط یک کار را انجام دهد و اگر وظایف آن گسترش یافت، باید برای برای آن کامپوننت های زیر مجموعه Subcomponent تعریف کرد و وظایف اضافی را به آنها سپرد.

از آنجایی که اغلب یک مدل داده جیسون (JSON Data Model) به کاربر نشان داده میشود، متوجه خواهید شد که اگر این مدل درست ساخته شده باشد، رابط کاربری و ساختار کامپوننت های شما هم به درستی قابل ترسیم و تعیین خواهد بود.
این بدان دلیل است که مدل داده (Data Model) و رابط کاربری معمولا از یک معماری اطلاعات (information architecture) یکسان تبعیت میکنند.
رابط کاربری را طوری به کامپوننت های مختلف تقسیم کنید که هر کامپوننت با بخش خاصی از مدل داده مرتبط باشد.

![Component diagram](../images/blog/thinking-in-react-components.png)

در این تصویر می بینید که ما پنج کامپوننت در برنامه خود داریم و اطلاعاتی که هر کامپوننت نمایش میدهد را با حروف ایتالیک مشخص کرده ایم:

  1. **`FilterableProductTable` (نارنجی):** شامل تمام برنامه 
  2. **`SearchBar` (آبی):** *ورودی های کاربر* را دریافت میکند
  3. **`ProductTable` (سبز):** تمامی *مجموعه اطلاعات* را با توجه به *ورودی کاربر* نمایش داده و اطلاعات را فیلتر میکند
  4. **`ProductCategoryRow` (فیروزه ای):** یک تیتر را برای هر *دسته* نمایش میدهد
  5. **`ProductRow` (قرمز):** یک ردیف را برای هر *محصول* نمایش میدهد

اگر نگاهی به کامپوننت `ProductTable`بیندازید، متوجه میشوید که تیترهای جدول (شامل "Name" و “Price”) کامپوننت جداگانه ای ندارند که بیشتر یک موضوع سلیقه ای است و دلایل و استدلال هایی برای استفاده یا عدم استفاده از یک کامپوننت جداگانه برای آنها وجود دارد.

در این مثال، آن را بخشی از  `ProductTable` قرار دادیم، چرا که جزئی از *مجموعه داده ها data collection* بوده و رندر کردن آن وظیفه `ProductTable` است.
با این حال، اگر هدر جدول پیچیده تر شود (مثلا اگر گزینه ای برای مرتب کردن لیست محصولات اضافه میکردیم)، مطمئنا منطقی تر بود که آنها در یک کامپوننت جداگانه با نام `ProductTableHeader` بگذاریم

حالا که کامپوننت های موجود در پروژه را مشخص کردیم، وقتش رسیده که سلسله مراتب آنها را نیز تعیین کنیم. کامپوننت هایی که با توجه به مدل، درون یک کامپوننت دیگر قرار میگیرند، فرزند آن محسوب میشوند:

  * `FilterableProductTable`
    * `SearchBar`
    * `ProductTable`
      * `ProductCategoryRow`
      * `ProductRow`

## قدم دوم: یک نسخه ایستا (Static) در ری‌اکت بسازید {#step-2-build-a-static-version-in-react}

<p data-height="600" data-theme-id="0" data-slug-hash="BwWzwm" data-default-tab="js" data-user="lacker" data-embed-version="2" class="codepen">این بخش را در <a href="https://codepen.io/gaearon/pen/BwWzwm">فکر کردن در چارچوب ری‌اکت: گام دوم</a> روی <a href="https://codepen.io">CodePen</a> ببینید.</p>
<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>

بعد از اینکه سلسله مراتب را مشخص کردید، نوبت به پیاده سازی اپ میرسد. راحتترین راه این است که نسخه ای بسازید که مدل داده ها را میگیرد و رابط کاربری را تولید میکند اما هیچ تعاملی با کاربر ندارد.
بهتر است که این دو فرایند (نوشتن نسخه تعاملی و ایستا Static) را از هم جدا کنیم، به این دلیل که ساخت نسخه ایستا، به مقدار زیادی نوشتن و مقدار کمی فکر کردن نیاز دارد. اما اضافه کردن امکان تعامل و پویایی، احتیاج به مقدار زیادی تفکر دارد و نیاز آن به نوشتن بسیار کمتر است. دلیلش را در ادامه خواهیم دید.


برای ساخت یک نسخه ایستا که مدل داده را رندر کند و نمایش دهد، باید کامپوننت هایی بسازید که از بقیه کامپوننت ها استفاده میکنند و داده ها را از طریق *props* انتقال میدهند. *Props* امکانی است که بوسیله آن، داده ها از کامپوننت والد parent به کامپوننت فرزند child منتقل میشوند. 
اگر که با مفهوم state آشنایی دارید، **هرگز از آن برای ساخت نسخه ایستا استفاده نکنید!** State برای ایجاد تعامل طراحی شده و داده ای است که در طول زمان تغییر میکند و از آنجایی که فعلا روی نسخه ایستا کار میکنیم، نیازی به آن نخواهیم داشت.

میتوانید روند ساخت را از بالا به پایین یا از پایین به بالا شروع کنید. به این معنا که هم میتوانید از بالاترین کامپوننت در سلسله مراتب آغاز کنید (مثلا `FilterableProductTable`) یا از کامپوننت هایی که در سطوح پایین تری قرار دارند (مثل `ProductRow`). در مثال ها ساده تر، معمولا شروع از بالا به پایین راحت تر است. در حالیکه در پروژه های بزرگتر، بهتر است که از پایین به بالا پیش بروید و همزمان با ساخت اپ، برای آن تست نیز بنویسید.

در پایان این گام، شما کتابخانه ای از کامپوننت ها خواهید داشت که مدل داده data model را رندر میکند. از آنجایی که با نسخه ایستا سر و کار داریم، کامپوننت ها تنها متد `render()` خواهند داشت.
کامپوننتی که در راس سلسله مراتب قرار دارد (یعنی `FilterableProductTable`) مدل داده ها را بعنوان یک prop دریافت میکند.
اگر تغییراتی را در مدل داده های زیربنایی پروژه ایجاد کنید و دوباره `ReactDOM.render()` را صدا بزنید، رابط کاربری به روز رسانی update خواهد شد و میتوانید ببینید که رابط کاربری چگونه و در کجا تغییر میکند.
**جریان یکطرفه داده one-way data flow** در ری‌اکت (که با نام *الزام و محدودیت یک طرفه one-way binding* نیز شناخته میشود) همه چیز را ماژولار و سریع نگه میدارد.

اگر برای اجرای این بخش به کمک نیاز داشتید، به [React docs](/docs/) مراجعه کنید.

### یک مکث مختصر: props در مقابل state {#a-brief-interlude-props-vs-state}

دو نوع داده "نمونه" (model) در ری¬اکت وجود دارد و خیلی مهم است که تفاوت این دو را بدانیم: اگر خیلی در این مورد مطمئن نیستید، نگاهی به  [مستندات رسمی ری‌اکت ](/docs/state-and-lifecycle.html) بیندازید.
علاوه براین، میتوانید به بخش [سوالات پرتکرار: تفاوت میان state و props چیست؟](/docs/faq-state.html#what-is-the-difference-between-state-and-props) مراجعه کنید.

## قدم سوم: مشخص کردن یک نمونه حداقلی اما کامل از state های موردنیاز در رابط کاربری {#step-3-identify-the-minimal-but-complete-representation-of-ui-state}

برای تعاملی کردن رابط کاربری، باید بتوانید در مدل داده زیربنایی پروژه (همان داده¬های اولیه) تغییر ایجاد کنید. اینکار در ری¬اکت از طریق **state** انجام میشود.

برای ساخت اپ به صورت صحیح، ابتدا باید به مجموعه ای حداقلی از داده های قابل تغییر فکر کنید که در پروژه شما نیاز است. کلید این موضوع، [اصل *خودت را تکرار نکن*](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) است.
تعیین کنید که در حال حاضر، مختصرترین مجموعه state که برنامه شما نیاز دارد چیست و بقیه موارد را به مرور، و در زمان لزوم محاسبه و تعیین کنید.

برای مثال، اگر یک برنامه برای لیست کارها TODO List طراحی میکنید، یک آرایه array از آیتم های موجود در لیست کارها را در دسترس نگه دارید. اما دیگر نیازی به تعیین یک state برای شمارش آیتم ها ندارید. به جای آن، زمان رندر کردن تعداد، میتوانید از طول آرایه آیتم ها (Array.length) استفاده کنید.

تمام بخش های داده در مثال خودمان را در نظر بگیرید:

  * یک لیست اصلی از محصولات
  * متنی که کاربر جستجو میکند
  * مقدار (value) چک باکس
  * لیست محصولات فیلتر شده پس از جستجو توسط کاربر

به طور جداگانه سراغ هر یک از این موارد میرویم تا ببینیم که کدامشان state هستند. درمورد هر بخش، این 3 سوال را از خودتان بپرسید:

  1. آیا این داده از طرف یک کامپوننت والد و بوسیله props انتقال داده شده؟ اگر جواب مثبت است، پس احتمالا این داده state نیست.
  2. آیا در طول زمان بدون تغییر می ماند؟ اگر اینطور است پس احتمالا باز هم state نیست.
  3. آیا میتوانید آن را بر اساس یک state یا props موجود محاسبه کنید؟ (مثل همان طول لیست کارها!) اگر اینطور است، پس حتما این داده  state نیست.

لیست اولیه و اصلی محصولات، بعنوان یک props منتقل میشود، بنابراین state نیست. اما به نظر میرسد که متن جستجو و مقدار چک باکس state هستند چرا که در طول زمان تغییر میکنند و نمیتوان آن ها را بوسیله داده دیگری محاسبه کرد. در نهایت، لیست محصولات فیلتر شده پس از جستجو هم state نیست، چرا که میتوان آن را از ترکیب لیست اصلی و اولیه با متن سرچ کاربر و مقدار چک باکس بدست آورد.

پس در مجموع، state این اپ عبارتند از:

  * متنی که کاربر در فیلد جستجو وارد میکند
  * مقدار (value) چک باکس

## قدم چهارم: مشخص کنید که state در کجا باید قرار بگیرد {#step-4-identify-where-your-state-should-live}

<p data-height="600" data-theme-id="0" data-slug-hash="qPrNQZ" data-default-tab="js" data-user="lacker" data-embed-version="2" class="codepen">این بخش را در <a href="https://codepen.io/gaearon/pen/qPrNQZ">فکر کردن در چارچوب ری‌اکت: گام چهارم</a> روی <a href="https://codepen.io">CodePen</a> ببینید.</p>

بعد از اینکه ما حداقل state مورد نیاز در پروژه را مشخص کردیم، نوبت این است که بدانیم هر state باید در کدام کامپوننت قرار بگیرد.

به یاد داشته باشید: ری¬اکت بر مبنای جریان یک طرفه و رو به پایین داده در سلسله مراتب کامپوننت ها کار میکند. ممکن است این موضوع که کدام کامپوننت، کدام state را در خود جا میدهد، فورا مشخص و واضح نباشد.  **اغلب این مساله، چالش برانگیزترین بخش برای افرادیست که تازه با ری‌اکت آشنا شده اند.**

پس برای اینکه متوجه موضوع بشوید، این قدم ها را برای هر state در برنامه خود دنبال کنید:

  * کامپوننت هایی را که چیزی را براساس آن state رندر میکنند، مشخص کنید.
  * یک کامپوننت مشترک صاحب state را پیدا کنید (کامپوننتی که در سلسله مراتب برنامه، بالاتر از دیگر کامپوننت های استفاده کننده از state قرار میگیرد و خود نیز از آن state استفاده میکند)
  * صاحب مشترک یا کامپوننت دیگری که در سلسله مراتب، بالاتر قرار میگیرد، باید صاحب state باشند.
  * اگر نتوانستید کامپوننتی را پیدا کنید که قرار دادن state در آن منطقی باشد، یک کامپوننت جدید ایجاد کنید که منحصرا برای نگهداری state باشد و آن را جایی بالاتر از صاحب مشترک state (در سلسله مراتب کامپوننت ها) قرار دهید.

حالا این استراتژی را برای برنامه خودمان اجرا کنیم:

  * کامپوننت `ProductTable` نیاز دارد که براساس state، لیست محصولات را فیلتر کند و کامپوننت `SearchBar` هم نیاز دارد که متن جستجو و مقدار چک باکس را نمایش دهد (دو state موجود در برنامه)
  * صاحب مشترک در این مثال، کامپوننت `FilterableProductTable` است.
  * پس منطقی به نظر میرسد که state ها را در کامپوننت `FilterableProductTable` قرار دهیم.

به این ترتیب، در ابتدا ویژگی `this.state = {filterText: '', inStockOnly: false}` را در بخش `constructor`در کامپوننت `FilterableProductTable` قرار میدهیم تا state ابتدایی برنامه شما را نشان دهد.

سپس، `filterText` و `inStockOnly` را به کامپوننت های `ProductTable` و `SearchBar` بعنوان props انتقال میدهیم. 
درنهایت، این props برای فیلتر ردیف های محصولات در `ProductTable` و مشخص کردن مقدار در چک باکس موجود در `SearchBar` به کار میروند.

حالا میتوانید ببینید که برنامه شما چطور عمل میکند: `filterText` را به `"ball"` تغییر بدید و برنامه را دوباره بارگذاری (refresh) کنید. خواهید دید که جدول داده ها به درستی تغییر میکند.

## قدم پنجم: اضافه کردن جریان معکوس داده {#step-5-add-inverse-data-flow}

<p data-height="600" data-theme-id="0" data-slug-hash="LzWZvb" data-default-tab="js,result" data-user="rohan10" data-embed-version="2" data-pen-title="Thinking In React: Step 5" class="codepen">این بخش را در <a href="https://codepen.io/gaearon/pen/LzWZvb">فکر کردن در چارچوب ری‌اکت: گام پنجم</a> در <a href="https://codepen.io">CodePen</a> ببینید.</p>

تا به اینجای کار، ما برنامه ای ساختیم که به طور صحیح و به شکل تابعی از props و state، رندر میشد و جریان داده در آن از بالا به پایین بود.
اما حالا زمان آن است که برنامه، جریان داده را به شکل معکوس و رو به بالا پشتیبانی کند: فرم های موجود در پایین ترین بخش سلسله مراتب کامپوننت ها، باید بتوانند state درون کامپوننت `FilterableProductTable` را تغییر دهند.

ری‌اکت، این جریان داده را ساده و شفاف میکند تا به کمک آن، بتوانید طرز کار برنامه تان را درک کنید، اما این مساله احتیاج به نوشتن و تایپ بیشتری نسبت به data binding دو طرفه و مرسوم دارد.

اگه در فیلد جستجو تایپ کنید یا مقدار چک باکس را تغییر دهید (تیک آن را فعال کنید) خواهید که ری‌اکت، این تغییرات را نادیده میگیرد. این موضوع عمدی است، چرا که ما تعیین کردیم، `value` در `input` همواره با مقدار  `state` که از کامپوننت `FilterableProductTable` منتقل میشود، برابر باشد.

بیایید به این فکر کنیم که میخواهیم چه اتفاقی بیفتد؟ میخواهیم مطمئن شویم که هر زمان کاربر، تغییراتی را در فرم (فیلد جستجو یا چک باکس) اعمال میکند، state به روز رسانی شده و تغییرات را منعکس کند. 
از آنجایی که کامپوننت ها فقط مجاز به تغییر state موجود در خودشان هستند، کامپوننت `FilterableProductTable` کال بک هایی (callback) را به کامپوننت`SearchBar` انتقال میدهد تا هر وقت نیاز به تغییر state وجود داشت، اجرا شوند.
میتوانیم از رویداد `onChange` برای ورودی ها استفاده کنیم تا به این طریق، کامپوننت `FilterableProductTable` از لزوم اجرای تغییر مطلع شود.
آن کال بک که از کامپوننت `FilterableProductTable` انتقال می یابد،  `setState()` است و باعث تغییر و به روز رسانی (update) اپ میشود.

## همین! {#and-thats-it}

امیدواریم که این مطلب، به شما ایده داده باشد که چگونه باید درباره ساختن کامپوننت ها و برنامه ها در ری¬اکت فکر کنید. البته ممکن است که میزان نوشتن، بیشتر از حدی باشد که به آن عادت دارید، اما به یاد داشته باشید که کد، بیشتر از اینکه نوشته شود، خوانده میشود و خواندن این کد که شکل ماژولار، ساده و شفاف نوشته شده است، بسیار راحت تر خواهد بود.

به محض اینکه ساخت کتابخانه های بزرگ متشکل از کامپوننت ها را شروع کنید، بابت این شفافیت و ماژولار بودن سپاسگزار خواهید شد، و با وجود امکان استفاده مجدد از کدها، تعداد خطوط کد شما، شروع به آب رفتن میکند و کوچکتر و کوتاه تر خواهند شد!  :)